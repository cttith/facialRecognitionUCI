col_stddevs_train <- attr(train_data, "scaled:scale")
test_data <- scale(test_data,
center = col_means_train,
scale = col_stddevs_train)
train_labels <- to_categorical(as.numeric(train_labels)-1)
# e.) ANN layout with, fully-connected hidden layer of 64 RELU units
# single linear neuron in the output layer
model <- keras_model_sequential(layers=list(
layer_dense(units = 64, activation = "relu",input_shape = dim(train_data)[2]),
layer_dense(units = 1)))
# f.) compile model
compile(model,
loss = "mse",
optimizer = optimizer_rmsprop(),
metrics = list("mean_absolute_error"))
# g.) 300 epochs, batch size 20, validation split 0.2 ; plot
history <- fit(model,
train_data, train_labels,
epochs = 300,
batch_size = 20,
validation_split = 0.2)
plot(history, metrics="mean_absolute_error",smooth=F)
# h.) evaluate performance on test data. Overall mean absolute error?
eval.results <- evaluate(model,
test_data,
test_labels,
verbose = 0)
mae <- eval.results$mean_absolute_error
# i.)
library(keras)
View(Hitters)
View(Hitters)
Hitters <- na.omit(Hitters)
Hitters$LogSalary <- log(Hitters$Salary)
library(keras)
library(ISLR)
attach(Hitters)
Hitters <- na.omit(Hitters)
Hitters$LogSalary <- log(Hitters$Salary)
Hitters$Salary <- NULL
Hitters
n <- nrow(Hitters)
p <- ncol(Hitters)-1
set.seed(1)
train <- sample(n, 0.8*n)
# b.) train/test data
train_data <- Hitters[train, 1:p]
train_labels <- Hitters[train, p+1]
test_data <- Hitters[-train, 1:p]
test_labels <- Hitters[-train, p+1]
train_data$League <- to_categorical(as.numeric(train_data$League)-1)
.libPaths()
reticulate::py_config()
reticulate::py_discover_config()
reticulate::py_discover_config(keras)
reticulate::py_discover_config("keras")
install_keras()
library(qdapRegex)
library(pixmap)
library(magick)
wd <- getwd()
fullDir = paste(wd,"/scale4Faces/",sep="")
print(fullDir)
all.files <- list.files(path=fullDir)
n.imageIndex = 1
emotionLabel <- NULL
positionLabel <- NULL
pixelMap <- NULL
for (fileName in all.files){
currVec = rm_between(fileName, "_", "_", extract=TRUE)
emotionLabel[n.imageIndex] <- currVec[[1]][2]
positionLabel[n.imageIndex] <- currVec[[1]][1]
magickObj <- image_read(paste(fullDir,fileName,sep=""))         # use magick to read pgm extension
cimgObj <- magick2cimg(magickObj)                       # convert magick to cimg, for functionality
pixelMap[[n.imageIndex]] <- cimgObj
n.imageIndex <- n.imageIndex + 1
}
# bdf flattens to data.frame (list) ; pixelMap[[1]] is a multi-dimensional list
#bdf <- as.data.frame(pixelMap[[1]])
#typeof(bdf)
typeof(pixelMap)
par(mfrow=c(2,2))
plot(pixelMap[[1]],
main=paste("Size:", dim(pixelMap[[1]])[1],"x", dim(pixelMap[[1]])[2]))
plot(pixelMap[[2]],
main=paste("Size:", dim(pixelMap[[2]])[1],"x", dim(pixelMap[[2]])[2]))
plot(pixelMap[[3]],
main=paste("Size:", dim(pixelMap[[3]])[1],"x", dim(pixelMap[[3]])[2]))
plot(pixelMap[[4]],
main=paste("Size:", dim(pixelMap[[4]])[1],"x", dim(pixelMap[[4]])[2]))
par(mfrow=c(1,1))
setwd("C:/Users/Christian/Desktop/COSC/FALL 2018/MATH 4397/proj/facialRecognitionUCI")
library(qdapRegex)
library(pixmap)
library(magick)
wd <- getwd()
fullDir = paste(wd,"/scale4Faces/",sep="")
print(fullDir)
all.files <- list.files(path=fullDir)
n.imageIndex = 1
emotionLabel <- NULL
positionLabel <- NULL
pixelMap <- NULL
for (fileName in all.files){
currVec = rm_between(fileName, "_", "_", extract=TRUE)
emotionLabel[n.imageIndex] <- currVec[[1]][2]
positionLabel[n.imageIndex] <- currVec[[1]][1]
magickObj <- image_read(paste(fullDir,fileName,sep=""))         # use magick to read pgm extension
cimgObj <- magick2cimg(magickObj)                       # convert magick to cimg, for functionality
pixelMap[[n.imageIndex]] <- cimgObj
n.imageIndex <- n.imageIndex + 1
}
# bdf flattens to data.frame (list) ; pixelMap[[1]] is a multi-dimensional list
#bdf <- as.data.frame(pixelMap[[1]])
#typeof(bdf)
typeof(pixelMap)
par(mfrow=c(2,2))
plot(pixelMap[[1]],
main=paste("Size:", dim(pixelMap[[1]])[1],"x", dim(pixelMap[[1]])[2]))
plot(pixelMap[[2]],
main=paste("Size:", dim(pixelMap[[2]])[1],"x", dim(pixelMap[[2]])[2]))
plot(pixelMap[[3]],
main=paste("Size:", dim(pixelMap[[3]])[1],"x", dim(pixelMap[[3]])[2]))
plot(pixelMap[[4]],
main=paste("Size:", dim(pixelMap[[4]])[1],"x", dim(pixelMap[[4]])[2]))
par(mfrow=c(1,1))
library("magick", lib.loc="~/R/win-library/3.5")
library(qdapRegex)
library(pixmap)
library(magick)
wd <- getwd()
fullDir = paste(wd,"/scale4Faces/",sep="")
print(fullDir)
all.files <- list.files(path=fullDir)
n.imageIndex = 1
emotionLabel <- NULL
positionLabel <- NULL
pixelMap <- NULL
for (fileName in all.files){
currVec = rm_between(fileName, "_", "_", extract=TRUE)
emotionLabel[n.imageIndex] <- currVec[[1]][2]
positionLabel[n.imageIndex] <- currVec[[1]][1]
magickObj <- image_read(paste(fullDir,fileName,sep=""))         # use magick to read pgm extension
cimgObj <- magick2cimg(magickObj)                       # convert magick to cimg, for functionality
pixelMap[[n.imageIndex]] <- cimgObj
n.imageIndex <- n.imageIndex + 1
}
# bdf flattens to data.frame (list) ; pixelMap[[1]] is a multi-dimensional list
#bdf <- as.data.frame(pixelMap[[1]])
#typeof(bdf)
typeof(pixelMap)
par(mfrow=c(2,2))
plot(pixelMap[[1]],
main=paste("Size:", dim(pixelMap[[1]])[1],"x", dim(pixelMap[[1]])[2]))
plot(pixelMap[[2]],
main=paste("Size:", dim(pixelMap[[2]])[1],"x", dim(pixelMap[[2]])[2]))
plot(pixelMap[[3]],
main=paste("Size:", dim(pixelMap[[3]])[1],"x", dim(pixelMap[[3]])[2]))
plot(pixelMap[[4]],
main=paste("Size:", dim(pixelMap[[4]])[1],"x", dim(pixelMap[[4]])[2]))
par(mfrow=c(1,1))
library(qdapRegex)
library(pixmap)
library(magick)
wd <- getwd()
fullDir = paste(wd,"/scale4Faces",sep="")
print(fullDir)
all.files <- list.files(path=fullDir)
n.imageIndex = 1
emotionLabel <- NULL
positionLabel <- NULL
pixelMap <- NULL
for (fileName in all.files){
currVec = rm_between(fileName, "_", "_", extract=TRUE)
emotionLabel[n.imageIndex] <- currVec[[1]][2]
positionLabel[n.imageIndex] <- currVec[[1]][1]
magickObj <- image_read(paste(fullDir,fileName,sep=""))         # use magick to read pgm extension
cimgObj <- magick2cimg(magickObj)                       # convert magick to cimg, for functionality
pixelMap[[n.imageIndex]] <- cimgObj
n.imageIndex <- n.imageIndex + 1
}
# bdf flattens to data.frame (list) ; pixelMap[[1]] is a multi-dimensional list
#bdf <- as.data.frame(pixelMap[[1]])
#typeof(bdf)
typeof(pixelMap)
par(mfrow=c(2,2))
plot(pixelMap[[1]],
main=paste("Size:", dim(pixelMap[[1]])[1],"x", dim(pixelMap[[1]])[2]))
plot(pixelMap[[2]],
main=paste("Size:", dim(pixelMap[[2]])[1],"x", dim(pixelMap[[2]])[2]))
plot(pixelMap[[3]],
main=paste("Size:", dim(pixelMap[[3]])[1],"x", dim(pixelMap[[3]])[2]))
plot(pixelMap[[4]],
main=paste("Size:", dim(pixelMap[[4]])[1],"x", dim(pixelMap[[4]])[2]))
par(mfrow=c(1,1))
library(qdapRegex)
library(pixmap)
library(magick)
wd <- getwd()
fullDir = paste(wd,"/scale4Faces/",sep="")
print(fullDir)
all.files <- list.files(path=fullDir)
n.imageIndex = 1
emotionLabel <- NULL
positionLabel <- NULL
pixelMap <- NULL
for (fileName in all.files){
currVec = rm_between(fileName, "_", "_", extract=TRUE)
emotionLabel[n.imageIndex] <- currVec[[1]][2]
positionLabel[n.imageIndex] <- currVec[[1]][1]
magickObj <- image_read(paste(fullDir,fileName,sep=""))         # use magick to read pgm extension
cimgObj <- magick2cimg(magickObj)                       # convert magick to cimg, for functionality
pixelMap[[n.imageIndex]] <- cimgObj
n.imageIndex <- n.imageIndex + 1
}
# bdf flattens to data.frame (list) ; pixelMap[[1]] is a multi-dimensional list
#bdf <- as.data.frame(pixelMap[[1]])
#typeof(bdf)
typeof(pixelMap)
par(mfrow=c(2,2))
plot(pixelMap[[1]],
main=paste("Size:", dim(pixelMap[[1]])[1],"x", dim(pixelMap[[1]])[2]))
plot(pixelMap[[2]],
main=paste("Size:", dim(pixelMap[[2]])[1],"x", dim(pixelMap[[2]])[2]))
plot(pixelMap[[3]],
main=paste("Size:", dim(pixelMap[[3]])[1],"x", dim(pixelMap[[3]])[2]))
plot(pixelMap[[4]],
main=paste("Size:", dim(pixelMap[[4]])[1],"x", dim(pixelMap[[4]])[2]))
par(mfrow=c(1,1))
library(qdapRegex)
library(pixmap)
library(magick)
library(imager)
wd <- getwd()
fullDir = paste(wd,"/scale4Faces/",sep="")
print(fullDir)
all.files <- list.files(path=fullDir)
n.imageIndex = 1
emotionLabel <- NULL
positionLabel <- NULL
pixelMap <- NULL
for (fileName in all.files){
currVec = rm_between(fileName, "_", "_", extract=TRUE)
emotionLabel[n.imageIndex] <- currVec[[1]][2]
positionLabel[n.imageIndex] <- currVec[[1]][1]
magick2
magickObj <- image_read(paste(fullDir,fileName,sep=""))         # use magick to read pgm extension
cimgObj <- magick2cimg(magickObj)                       # convert magick to cimg, for functionality
pixelMap[[n.imageIndex]] <- cimgObj
n.imageIndex <- n.imageIndex + 1
}
# bdf flattens to data.frame (list) ; pixelMap[[1]] is a multi-dimensional list
#bdf <- as.data.frame(pixelMap[[1]])
#typeof(bdf)
typeof(pixelMap)
par(mfrow=c(2,2))
plot(pixelMap[[1]],
main=paste("Size:", dim(pixelMap[[1]])[1],"x", dim(pixelMap[[1]])[2]))
plot(pixelMap[[2]],
main=paste("Size:", dim(pixelMap[[2]])[1],"x", dim(pixelMap[[2]])[2]))
plot(pixelMap[[3]],
main=paste("Size:", dim(pixelMap[[3]])[1],"x", dim(pixelMap[[3]])[2]))
plot(pixelMap[[4]],
main=paste("Size:", dim(pixelMap[[4]])[1],"x", dim(pixelMap[[4]])[2]))
par(mfrow=c(1,1))
library(qdapRegex)
library(pixmap)
library(magick)
library(imager)
wd <- getwd()
fullDir = paste(wd,"/scale4Faces/",sep="")
print(fullDir)
all.files <- list.files(path=fullDir)
n.imageIndex = 1
emotionLabel <- NULL
positionLabel <- NULL
pixelMap <- NULL
for (fileName in all.files){
currVec = rm_between(fileName, "_", "_", extract=TRUE)
emotionLabel[n.imageIndex] <- currVec[[1]][2]
positionLabel[n.imageIndex] <- currVec[[1]][1]
magick2
magickObj <- image_read(paste(fullDir,fileName,sep=""))         # use magick to read pgm extension
cimgObj <- magick2cimg(magickObj)                       # convert magick to cimg, for functionality
pixelMap[[n.imageIndex]] <- cimgObj
n.imageIndex <- n.imageIndex + 1
}
# bdf flattens to data.frame (list) ; pixelMap[[1]] is a multi-dimensional list
#bdf <- as.data.frame(pixelMap[[1]])
#typeof(bdf)
typeof(pixelMap)
par(mfrow=c(2,2))
plot(pixelMap[[1]],
main=paste("Size:", dim(pixelMap[[1]])[1],"x", dim(pixelMap[[1]])[2]))
plot(pixelMap[[2]],
main=paste("Size:", dim(pixelMap[[2]])[1],"x", dim(pixelMap[[2]])[2]))
plot(pixelMap[[3]],
main=paste("Size:", dim(pixelMap[[3]])[1],"x", dim(pixelMap[[3]])[2]))
plot(pixelMap[[4]],
main=paste("Size:", dim(pixelMap[[4]])[1],"x", dim(pixelMap[[4]])[2]))
par(mfrow=c(1,1))
library(qdapRegex)
library(pixmap)
library(magick)
library(imager)
wd <- getwd()
fullDir = paste(wd,"/scale4Faces/",sep="")
print(fullDir)
all.files <- list.files(path=fullDir)
n.imageIndex = 1
emotionLabel <- NULL
positionLabel <- NULL
pixelMap <- NULL
for (fileName in all.files){
currVec = rm_between(fileName, "_", "_", extract=TRUE)
emotionLabel[n.imageIndex] <- currVec[[1]][2]
positionLabel[n.imageIndex] <- currVec[[1]][1]
magick2
magickObj <- image_read(paste(fullDir,fileName,sep=""))         # use magick to read pgm extension
cimgObj <- magick2cimg(magickObj)                       # convert magick to cimg, for functionality
pixelMap[[n.imageIndex]] <- cimgObj
n.imageIndex <- n.imageIndex + 1
}
# bdf flattens to data.frame (list) ; pixelMap[[1]] is a multi-dimensional list
#bdf <- as.data.frame(pixelMap[[1]])
#typeof(bdf)
typeof(pixelMap)
par(mfrow=c(2,2))
plot(pixelMap[[1]],
main=paste("Size:", dim(pixelMap[[1]])[1],"x", dim(pixelMap[[1]])[2]))
plot(pixelMap[[2]],
main=paste("Size:", dim(pixelMap[[2]])[1],"x", dim(pixelMap[[2]])[2]))
plot(pixelMap[[3]],
main=paste("Size:", dim(pixelMap[[3]])[1],"x", dim(pixelMap[[3]])[2]))
plot(pixelMap[[4]],
main=paste("Size:", dim(pixelMap[[4]])[1],"x", dim(pixelMap[[4]])[2]))
par(mfrow=c(1,1))
library(qdapRegex)
library(pixmap)
library(magick)
library(imager)
wd <- getwd()
fullDir = paste(wd,"/scale4Faces/",sep="")
print(fullDir)
all.files <- list.files(path=fullDir)
n.imageIndex = 1
emotionLabel <- NULL
positionLabel <- NULL
pixelMap <- NULL
for (fileName in all.files){
currVec = rm_between(fileName, "_", "_", extract=TRUE)
emotionLabel[n.imageIndex] <- currVec[[1]][2]
positionLabel[n.imageIndex] <- currVec[[1]][1]
magickObj <- image_read(paste(fullDir,fileName,sep=""))         # use magick to read pgm extension
cimgObj <- magick2cimg(magickObj)                       # convert magick to cimg, for functionality
pixelMap[[n.imageIndex]] <- cimgObj
n.imageIndex <- n.imageIndex + 1
}
# bdf flattens to data.frame (list) ; pixelMap[[1]] is a multi-dimensional list
#bdf <- as.data.frame(pixelMap[[1]])
#typeof(bdf)
typeof(pixelMap)
par(mfrow=c(2,2))
plot(pixelMap[[1]],
main=paste("Size:", dim(pixelMap[[1]])[1],"x", dim(pixelMap[[1]])[2]))
plot(pixelMap[[2]],
main=paste("Size:", dim(pixelMap[[2]])[1],"x", dim(pixelMap[[2]])[2]))
plot(pixelMap[[3]],
main=paste("Size:", dim(pixelMap[[3]])[1],"x", dim(pixelMap[[3]])[2]))
plot(pixelMap[[4]],
main=paste("Size:", dim(pixelMap[[4]])[1],"x", dim(pixelMap[[4]])[2]))
par(mfrow=c(1,1))
library(fastmatch)
# split data
#train_images <- array(dim=c(n.train.im, 28, 28))
#for (j in 1:n.train.im)  train_images[j,,]  <- train.images.28x28.gray[[rand.samp[j]]]
n <- length(pixelMap)     # num of imgs
set.seed(1)
train <- sample(n,0.8*n)
train_images <- NULL
train_images[[1]] <- pixelMap[train]
train_emotion <- emotionLabel[train]
test_images <- NULL
test_images[[1]] <- pixelMap[-train]
test_emotion <- emotionLabel[-train]
#####UP TO HERE, IT'S CORRECT, A1
numTrainImages = length(train_images)
train_final_images <- array(dim=c(numTrainImages, 32, 30))
for (j in 1:numTrainImages)  train_final_images[j,,]  <- train_images[[j]]
numTestImages = length(test_images)
test_final_images <- array(dim=c(numTestImages, 32, 30))
for (j in 1:numTestImages)  test_final_images[j,,]  <- train_images[[j]]
# one hot encoding
train_emotion_onehot <- fmatch(train_emotion, c("angry","happy","neutral","sad"))
test_emotion_onehot <- fmatch(test_emotion, c("angry","happy","neutral","sad"))
head(train_emotion, 10)
head(train_emotion_onehot, 10)
head(train_oneHot, 10)
train_oneHot <- to_categorical(train_emotion_onehot-1)
test_oneHot <- to_categorical(test_emotion_onehot-1)
head(test_emotion, 10)
head(test_emotion_onehot, 10)
head(test_oneHot, 10)
numTrainImages = length(train_images)
train_final_images <- array(dim=c(numTrainImages, 32, 30))
for (j in 1:numTrainImages)  train_final_images[j,,]  <- train_images[j]
numTestImages = length(test_images)
test_final_images <- array(dim=c(numTestImages, 32, 30))
for (j in 1:numTestImages)  test_final_images[j,,]  <- train_images[j]
train_emotion_onehot <- fmatch(train_emotion, c("angry","happy","neutral","sad"))
test_emotion_onehot <- fmatch(test_emotion, c("angry","happy","neutral","sad"))
head(train_emotion, 10)
head(train_emotion_onehot, 10)
head(train_oneHot, 10)
train_oneHot <- to_categorical(train_emotion_onehot-1)
test_oneHot <- to_categorical(test_emotion_onehot-1)
library(fastmatch)
library(keras)
# split data
#train_images <- array(dim=c(n.train.im, 28, 28))
#for (j in 1:n.train.im)  train_images[j,,]  <- train.images.28x28.gray[[rand.samp[j]]]
n <- length(pixelMap)     # num of imgs
set.seed(1)
train <- sample(n,0.8*n)
train_images <- NULL
train_images[[1]] <- pixelMap[train]
train_emotion <- emotionLabel[train]
test_images <- NULL
test_images[[1]] <- pixelMap[-train]
test_emotion <- emotionLabel[-train]
#####UP TO HERE, IT'S CORRECT, A1
numTrainImages = length(train_images)
train_final_images <- array(dim=c(numTrainImages, 32, 30))
for (j in 1:numTrainImages)  train_final_images[j,,]  <- train_images[j]
numTestImages = length(test_images)
test_final_images <- array(dim=c(numTestImages, 32, 30))
for (j in 1:numTestImages)  test_final_images[j,,]  <- train_images[j]
# one hot encoding
train_emotion_onehot <- fmatch(train_emotion, c("angry","happy","neutral","sad"))
test_emotion_onehot <- fmatch(test_emotion, c("angry","happy","neutral","sad"))
head(train_emotion, 10)
head(train_emotion_onehot, 10)
head(train_oneHot, 10)
train_oneHot <- to_categorical(train_emotion_onehot-1)
library(qdapRegex)
library(pixmap)
library(magick)
library(imager)
wd <- getwd()
fullDir = paste(wd,"/scale4Faces/",sep="")
print(fullDir)
all.files <- list.files(path=fullDir)
n.imageIndex = 1
emotionLabel <- NULL
positionLabel <- NULL
pixelMap <- NULL
for (fileName in all.files){
currVec = rm_between(fileName, "_", "_", extract=TRUE)
emotionLabel[n.imageIndex] <- currVec[[1]][2]
positionLabel[n.imageIndex] <- currVec[[1]][1]
magickObj <- image_read(paste(fullDir,fileName,sep=""))         # use magick to read pgm extension
cimgObj <- magick2cimg(magickObj)                       # convert magick to cimg, for functionality
pixelMap[[n.imageIndex]] <- cimgObj
n.imageIndex <- n.imageIndex + 1
}
# bdf flattens to data.frame (list) ; pixelMap[[1]] is a multi-dimensional list
#bdf <- as.data.frame(pixelMap[[1]])
#typeof(bdf)
typeof(pixelMap)
par(mfrow=c(2,2))
plot(pixelMap[[1]],
main=paste("Size:", dim(pixelMap[[1]])[1],"x", dim(pixelMap[[1]])[2]))
plot(pixelMap[[2]],
main=paste("Size:", dim(pixelMap[[2]])[1],"x", dim(pixelMap[[2]])[2]))
plot(pixelMap[[3]],
main=paste("Size:", dim(pixelMap[[3]])[1],"x", dim(pixelMap[[3]])[2]))
plot(pixelMap[[4]],
main=paste("Size:", dim(pixelMap[[4]])[1],"x", dim(pixelMap[[4]])[2]))
par(mfrow=c(1,1))
library(fastmatch)
library(keras)
# split data
#train_images <- array(dim=c(n.train.im, 28, 28))
#for (j in 1:n.train.im)  train_images[j,,]  <- train.images.28x28.gray[[rand.samp[j]]]
n <- length(pixelMap)     # num of imgs
set.seed(1)
train <- sample(n,0.8*n)
train_images <- NULL
train_images[[1]] <- pixelMap[train]
train_emotion <- emotionLabel[train]
test_images <- NULL
test_images[[1]] <- pixelMap[-train]
test_emotion <- emotionLabel[-train]
#####UP TO HERE, IT'S CORRECT, A1
numTrainImages = length(train_images)
train_final_images <- array(dim=c(numTrainImages, 32, 30))
for (j in 1:numTrainImages)  train_final_images[j,,]  <- train_images[j]
numTestImages = length(test_images)
test_final_images <- array(dim=c(numTestImages, 32, 30))
for (j in 1:numTestImages)  test_final_images[j,,]  <- train_images[j]
train_emotion_onehot <- fmatch(train_emotion, c("angry","happy","neutral","sad"))
test_emotion_onehot <- fmatch(test_emotion, c("angry","happy","neutral","sad"))
train_oneHot <- to_categorical(train_emotion_onehot-1)
library("keras", lib.loc="C:/Program Files/R/R-3.5.1/library")
train_oneHot <- to_categorical(train_emotion_onehot-1)
library(keras)
train_oneHot <- to_categorical(train_emotion_onehot-1)
reticulate::py_config("keras")
reticulate::py_config('keras')
reticulate::py_discover_config("keras")
use_condaenv("r-tensorflow")
install_keras()
